


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > MapData</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hk.ust.comp3111.api</a>
</div>

<h1>Coverage Summary for Class: MapData (hk.ust.comp3111.api)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MapData</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (22/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (95/95)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package hk.ust.comp3111.api;
&nbsp;
&nbsp;import hk.ust.comp3111.api.Vertex.TileType;
&nbsp;import hk.ust.comp3111.engine.Entity;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.Path;
&nbsp;import java.util.*;
&nbsp;import java.util.function.Consumer;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.IntStream;
&nbsp;
&nbsp;/**
&nbsp; * An object which contains the information of a game map.
&nbsp; */
&nbsp;public class MapData {
&nbsp;    /**
&nbsp;     * The width of the map.
&nbsp;     */
&nbsp;    public static final int DEFAULT_WIDTH = 30;
&nbsp;
&nbsp;    /**
&nbsp;     * The height of the map.
&nbsp;     */
&nbsp;    public static final int DEFAULT_HEIGHT = 30;
&nbsp;
&nbsp;    // (row, column) = (y, x) = get(y).get(x)
<b class="fc">&nbsp;    private List&lt;List&lt;Vertex&gt;&gt; vertices = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    private final Map&lt;Entity, Vertex&gt; entities = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Constructs a new MapData object from the given list of vertices.
&nbsp;     * The input list is a list of vertices, ordered by rows.
&nbsp;     * Please use Coord(Height, Width) for the vertices passed.
&nbsp;     * @param other The list of vertices to copy
&nbsp;     */
<b class="fc">&nbsp;    public MapData(List&lt;List&lt;Vertex&gt;&gt; other) {</b>
<b class="fc">&nbsp;        vertices = new ArrayList&lt;&gt;(other);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constructs a MapData object by reading from the given file.
&nbsp;     * @param input The path to read from
&nbsp;     * @throws IOException If the file cannot be read
&nbsp;     */
<b class="fc">&nbsp;    public MapData(Path input) throws IOException {</b>
<b class="fc">&nbsp;        List&lt;List&lt;Vertex.TileType&gt;&gt; types = Files.readAllLines(input).stream()</b>
<b class="fc">&nbsp;                .map(s -&gt; s.endsWith(&quot;,&quot;) ? s.substring(0, s.length() - 1) : s)</b>
<b class="fc">&nbsp;                .map(s -&gt; List.of(s.split(&quot;,&quot;)))</b>
<b class="fc">&nbsp;                .map(s -&gt; s.stream().map(String::trim)</b>
<b class="fc">&nbsp;                        .map(Integer::parseInt)</b>
<b class="fc">&nbsp;                        .map(Vertex.TileType::from).collect(Collectors.toList()))</b>
<b class="fc">&nbsp;                .toList();</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; DEFAULT_HEIGHT; i++) {</b>
<b class="fc">&nbsp;            List&lt;Vertex&gt; vertex = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            for (int j = 0; j &lt; DEFAULT_WIDTH; j++) {</b>
<b class="fc">&nbsp;                vertex.add(new Vertex(new Coord(j, i), types.get(i).get(j)));</b>
&nbsp;            }
<b class="fc">&nbsp;            vertices.add(vertex);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Optionally returns a {@link Optional Optional&amp;lt;Vertex&amp;gt;} at the specified coordinate.
&nbsp;     * @param c The coordinate to retrieve the vertex from
&nbsp;     * @return An optional containing the vertex if the coordinate is not out of bounds; an empty optional otherwise
&nbsp;     */
&nbsp;    public Optional&lt;Vertex&gt; at(Coord c) {
<b class="fc">&nbsp;        if (c.y() &lt; 0 || c.y() &gt;= DEFAULT_WIDTH || c.x() &lt; 0 || c.x() &gt;= DEFAULT_HEIGHT) {</b>
<b class="fc">&nbsp;            return Optional.empty();</b>
&nbsp;        }
<b class="fc">&nbsp;        return Optional.of(vertices.get(c.y()).get(c.x()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a copy of vertices of the current game map.
&nbsp;     * @return A copy of the list of vertices
&nbsp;     */
&nbsp;    public List&lt;List&lt;Vertex&gt;&gt; getVertices() {
<b class="fc">&nbsp;        return new ArrayList&lt;&gt;(vertices);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the vertex at the coordinates of the given vertex.
&nbsp;     * @param v The vertex to set
&nbsp;     */
&nbsp;    public void set(Vertex v) {
<b class="fc">&nbsp;        vertices.get(v.y()).set(v.x(), v);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Writes the object to the specified Path.
&nbsp;     * @param p The path to write to
&nbsp;     * @throws IOException If writing to the path failed
&nbsp;     */
&nbsp;    public void write(Path p) throws IOException {
<b class="fc">&nbsp;        Files.write(p, List.of(toCsv(vertices)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Converts a list of vertices to CSV format.
&nbsp;     * @param vertices The List of vertices to write, ordered by row
&nbsp;     * @return A string containing the formatted CSV
&nbsp;     */
&nbsp;    public static String toCsv(List&lt;List&lt;Vertex&gt;&gt; vertices) {
<b class="fc">&nbsp;        return vertices.stream().map(</b>
<b class="fc">&nbsp;                vs -&gt; vs.stream().map(v -&gt; v.getTileType().ordinal())</b>
<b class="fc">&nbsp;                        .map(i -&gt; Integer.toString(i))</b>
<b class="fc">&nbsp;                        .collect(Collectors.joining(&quot;, &quot;))</b>
<b class="fc">&nbsp;        ).collect(Collectors.joining(&quot;,\n&quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if a vertex can be passed by other entities.
&nbsp;     * @param vertex Vertex to be checked
&nbsp;     * @return True if this vertex can be passed, false otherwise
&nbsp;     */
&nbsp;    public boolean isPassable(Vertex vertex) {
<b class="fc">&nbsp;        return vertex.getTileType() != TileType.BARRIER;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Adds an entity to the map at the specified vertex.
&nbsp;     * @param vertex The vertex the entity is located at
&nbsp;     * @param entity The entity to add
&nbsp;     * @throws IllegalStateException If the vertex is impassable
&nbsp;     */
&nbsp;    public void addEntity(Vertex vertex, Entity entity) {
<b class="fc">&nbsp;        if (!isPassable(vertex)) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Adding entity &quot; + entity + &quot; to impassable vertex &quot; + vertex.getCoord());</b>
&nbsp;        }
<b class="fc">&nbsp;        entities.put(entity, vertex);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes an entity from the map.
&nbsp;     * @param entity The entity to remove
&nbsp;     */
&nbsp;    public void removeEntity(Entity entity) {
<b class="fc">&nbsp;        entities.remove(entity);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if an entity is in this map.
&nbsp;     * @param entity Entity whose presence in this map is to be tested
&nbsp;     * @return True if it exists, False otherwise
&nbsp;     */
&nbsp;    public boolean hasEntity(Entity entity) {
<b class="fc">&nbsp;        return entities.containsKey(entity);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the location (as a Vertex class) of the provided entity.
&nbsp;     * @param entity Entity whose location is wanted
&nbsp;     * @return The vertex the Entity is located at, or null if the Entity is not on the map
&nbsp;     */
&nbsp;    public Vertex entityLocation(Entity entity) {
<b class="fc">&nbsp;        return entities.get(entity);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a set view of the entities in this map.
&nbsp;     * Any changes in the map will be reflected here.
&nbsp;     * This returned set is immutable - do not edit it.
&nbsp;     * @return A set view of the underlying entity map
&nbsp;     */
&nbsp;    public Set&lt;Entity&gt; getEntities() {
<b class="fc">&nbsp;        return Collections.unmodifiableSet(entities.keySet());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Runs the supplied consumer on all vertices.
&nbsp;     * @param cons The action to perform on each vertex
&nbsp;     */
&nbsp;    public void forAll(Consumer&lt;Vertex&gt; cons) {
<b class="fc">&nbsp;        vertices.stream().flatMap(List::stream).forEach(cons);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Linearly interpolates between the starting vertex and the ending vertex.
&nbsp;     * @param start The starting position
&nbsp;     * @param end The ending position
&nbsp;     * @return A list of vertices from the current map which are interpolated
&nbsp;     */
&nbsp;    public List&lt;Vertex&gt; lerp(Vertex start, Vertex end) {
<b class="fc">&nbsp;        if (start.equals(end)) {</b>
<b class="fc">&nbsp;            return List.of(end);</b>
&nbsp;        }
&nbsp;        Vertex left, right, up, down;
<b class="fc">&nbsp;        if (start.x() &gt; end.x()) {</b>
<b class="fc">&nbsp;            right = start;</b>
<b class="fc">&nbsp;            left = end;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            right = end;</b>
<b class="fc">&nbsp;            left = start;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (start.y() &gt; end.y()) {</b>
<b class="fc">&nbsp;            up = start;</b>
<b class="fc">&nbsp;            down = end;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            up = end;</b>
<b class="fc">&nbsp;            down = start;</b>
&nbsp;        }
<b class="fc">&nbsp;        List&lt;Vertex&gt; ret = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        int dx = right.x() - left.x();</b>
<b class="fc">&nbsp;        if (dx == 0) {</b>
<b class="fc">&nbsp;            return IntStream.rangeClosed(down.y(), up.y())</b>
<b class="fc">&nbsp;                    .mapToObj(i -&gt; at(new Coord(left.x(), i)))</b>
<b class="fc">&nbsp;                    .flatMap(Optional::stream)</b>
<b class="fc">&nbsp;                    .collect(Collectors.toList());</b>
&nbsp;        }
<b class="fc">&nbsp;        double slope = (double) (right.y() - left.y()) / dx;</b>
<b class="fc">&nbsp;        double c = right.y() - right.x() * slope;</b>
<b class="fc">&nbsp;        for (int curX = left.x(); curX &lt; right.x(); curX++) {</b>
<b class="fc">&nbsp;            double nextStep = Math.abs(slope) &lt;= 1 ? 0.5 : 1;</b>
<b class="fc">&nbsp;            int nextY = (int) Math.round(slope * (curX + nextStep) + c);</b>
<b class="fc">&nbsp;            int curY = (int) Math.round(slope * curX + c);</b>
<b class="fc">&nbsp;            if (nextY == curY) {</b>
<b class="fc">&nbsp;                at(new Coord(curX, curY)).ifPresent(ret::add);</b>
&nbsp;            } else {
&nbsp;                IntStream stream;
<b class="fc">&nbsp;                if (nextY &gt; curY) {</b>
<b class="fc">&nbsp;                    stream = IntStream.range(curY, nextY);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    stream = IntStream.range(nextY, curY);</b>
&nbsp;                }
<b class="fc">&nbsp;                int copiedX = curX;</b>
<b class="fc">&nbsp;                ret.addAll(stream.mapToObj(i -&gt; at(new Coord(copiedX, i)))</b>
<b class="fc">&nbsp;                        .flatMap(Optional::stream)</b>
<b class="fc">&nbsp;                        .toList());</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        if (slope &lt; -1.0) {ret.add(left);}</b>
<b class="fc">&nbsp;        ret.add(right);</b>
<b class="fc">&nbsp;        return ret;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Optionally finds the entrance of the map, if it exists.
&nbsp;     * @return An optional containing the entrance of the map; an empty optional otherwise
&nbsp;     */
&nbsp;    public Optional&lt;Vertex&gt; findEntrance() {
<b class="fc">&nbsp;        return vertices.stream()</b>
<b class="fc">&nbsp;                .flatMap(List::stream)</b>
<b class="fc">&nbsp;                .filter(v -&gt; v.getTileType() == TileType.ENTRANCE)</b>
<b class="fc">&nbsp;                .findFirst();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Optionally finds the exit of the map, if it exists.
&nbsp;     * @return An optional containing the entrance of the map; an empty optional otherwise
&nbsp;     */
&nbsp;    public Optional&lt;Vertex&gt; findExit() {
<b class="fc">&nbsp;        return vertices.stream()</b>
<b class="fc">&nbsp;                .flatMap(List::stream)</b>
<b class="fc">&nbsp;                .filter(v -&gt; v.getTileType() == TileType.EXIT)</b>
<b class="fc">&nbsp;                .findFirst();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieves a List of vertices which are at some straight line distance away from the input.
&nbsp;     * @param other The vertex to look around
&nbsp;     * @param distance The straight line distance
&nbsp;     * @return The List of vertices retrieved
&nbsp;     */
&nbsp;    public List&lt;Vertex&gt; around(Vertex other, int distance) {
<b class="fc">&nbsp;        Coord otherCoord = other.getCoord();</b>
<b class="fc">&nbsp;        List&lt;Coord&gt; coordinates = List.of(</b>
<b class="fc">&nbsp;                otherCoord.translate(new Coord(-distance, 0)),</b>
<b class="fc">&nbsp;                otherCoord.translate(new Coord(distance, 0)),</b>
<b class="fc">&nbsp;                otherCoord.translate(new Coord(0, -distance)),</b>
<b class="fc">&nbsp;                otherCoord.translate(new Coord(0, distance)));</b>
<b class="fc">&nbsp;        return coordinates.stream().map(this::at)</b>
<b class="fc">&nbsp;                .flatMap(Optional::stream)</b>
<b class="fc">&nbsp;                .collect(Collectors.toList());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean equals(Object o) {
<b class="fc">&nbsp;        if (this == o) return true;</b>
<b class="fc">&nbsp;        if (!(o instanceof MapData mapData)) return false;</b>
<b class="fc">&nbsp;        return Objects.equals(vertices, mapData.vertices);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int hashCode() {
<b class="fc">&nbsp;        return Objects.hash(vertices);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-14 17:58</div>
</div>
</body>
</html>
