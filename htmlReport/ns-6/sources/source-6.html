


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > MapComponent</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hk.ust.comp3111.ui</a>
</div>

<h1>Coverage Summary for Class: MapComponent (hk.ust.comp3111.ui)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MapComponent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (72/72)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package hk.ust.comp3111.ui;
&nbsp;
&nbsp;import hk.ust.comp3111.api.Coord;
&nbsp;import hk.ust.comp3111.api.MapData;
&nbsp;import hk.ust.comp3111.api.Vertex;
&nbsp;
&nbsp;import javax.swing.*;
&nbsp;import java.awt.*;
&nbsp;import java.awt.image.BufferedImage;
&nbsp;import java.util.*;
&nbsp;import java.util.List;
&nbsp;import java.util.function.Function;
&nbsp;
&nbsp;import static hk.ust.comp3111.api.Vertex.TileType.BARRIER;
&nbsp;
&nbsp;/**
&nbsp; * A component containing the game map.
&nbsp; * Holds map data and the display panel.
&nbsp; */
&nbsp;public class MapComponent {
&nbsp;    /**
&nbsp;     * Defines the color for the shortest path.
&nbsp;     */
<b class="fc">&nbsp;    public static final Color SHORTEST_PATH_COLOR = Color.RED;</b>
&nbsp;    private final MapData mapData;
<b class="fc">&nbsp;    private final JPanel mapPanel = new JPanel();</b>
<b class="fc">&nbsp;    private final Map&lt;JPanel, Vertex&gt; lookupVertex = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;    private final List&lt;List&lt;JPanel&gt;&gt; panels = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    private final List&lt;Vertex&gt; shortestPath = new ArrayList&lt;&gt;();</b>
&nbsp;    /**
&nbsp;     * The pixels per panel.
&nbsp;     */
&nbsp;    public static final int PX = 30;
&nbsp;
&nbsp;    /**
&nbsp;     * Constructs a new MapComponent with all vertices being barriers.
&nbsp;     */
<b class="fc">&nbsp;    public MapComponent() {</b>
<b class="fc">&nbsp;        mapPanel.setLayout(new GridLayout(MapData.DEFAULT_HEIGHT + 1, MapData.DEFAULT_WIDTH + 1));</b>
<b class="fc">&nbsp;        List&lt;List&lt;Vertex&gt;&gt; vertices = init(c -&gt; new Vertex(c, BARRIER));</b>
<b class="fc">&nbsp;        mapData = new MapData(vertices);</b>
<b class="fc">&nbsp;        render();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constructs a new MapComponent with the specified MapData.
&nbsp;     * @param data The map data to use
&nbsp;     */
<b class="fc">&nbsp;    public MapComponent(MapData data) {</b>
<b class="fc">&nbsp;        Objects.requireNonNull(data);</b>
<b class="fc">&nbsp;        mapData = data;</b>
<b class="fc">&nbsp;        init(c -&gt; data.at(c).orElseThrow());</b>
<b class="fc">&nbsp;        render();</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;List&lt;Vertex&gt;&gt; init(Function&lt;Coord, Vertex&gt; func) {
<b class="fc">&nbsp;        mapPanel.setLayout(new GridLayout(MapData.DEFAULT_HEIGHT + 1, MapData.DEFAULT_WIDTH + 1));</b>
<b class="fc">&nbsp;        List&lt;List&lt;Vertex&gt;&gt; vertices = new ArrayList&lt;&gt;();</b>
&nbsp;        // Top numbers
<b class="fc">&nbsp;        for (int i = 0; i &lt;= MapData.DEFAULT_WIDTH; i++) {</b>
<b class="fc">&nbsp;            JPanel panel = new JPanel(new BorderLayout());</b>
<b class="fc">&nbsp;            panel.setPreferredSize(new Dimension(PX, PX));</b>
<b class="fc">&nbsp;            if (i != 0) {</b>
<b class="fc">&nbsp;                JLabel label = new JLabel(Integer.toString(i));</b>
<b class="fc">&nbsp;                label.setAlignmentX(Component.CENTER_ALIGNMENT);</b>
<b class="fc">&nbsp;                panel.add(label);</b>
&nbsp;            }
<b class="fc">&nbsp;            mapPanel.add(panel);</b>
&nbsp;        }
<b class="fc">&nbsp;        for (int i = 0; i &lt; MapData.DEFAULT_HEIGHT; i++) {</b>
<b class="fc">&nbsp;            List&lt;JPanel&gt; panel = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            List&lt;Vertex&gt; vertex = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            for (int j = 0; j &lt; MapData.DEFAULT_WIDTH; j++) {</b>
<b class="fc">&nbsp;                Vertex vert = func.apply(new Coord(j, i));</b>
<b class="fc">&nbsp;                vertex.add(vert);</b>
<b class="fc">&nbsp;                JPanel jPanel = new JPanel(new BorderLayout());</b>
<b class="fc">&nbsp;                jPanel.setSize(PX, PX);</b>
<b class="fc">&nbsp;                jPanel.setPreferredSize(new Dimension(PX, PX));</b>
<b class="fc">&nbsp;                panel.add(jPanel);</b>
<b class="fc">&nbsp;                lookupVertex.put(jPanel, vert);</b>
&nbsp;            }
<b class="fc">&nbsp;            vertices.add(vertex);</b>
<b class="fc">&nbsp;            panels.add(panel);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; MapData.DEFAULT_HEIGHT; i++) {</b>
&nbsp;            // Side numbers
<b class="fc">&nbsp;            JPanel labelPanel = new JPanel();</b>
<b class="fc">&nbsp;            JLabel label = new JLabel(Integer.toString(i + 1));</b>
<b class="fc">&nbsp;            label.setAlignmentX(Component.CENTER_ALIGNMENT);</b>
<b class="fc">&nbsp;            labelPanel.add(label);</b>
<b class="fc">&nbsp;            mapPanel.add(labelPanel);</b>
<b class="fc">&nbsp;            for (int j = 0; j &lt; MapData.DEFAULT_WIDTH; j++) {</b>
<b class="fc">&nbsp;                mapPanel.add(panels.get(i).get(j));</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return vertices;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the map panel to be added to the UI.
&nbsp;     * @return The map panel of this MapComponent
&nbsp;     */
&nbsp;    public JPanel getMainPanel() {
<b class="fc">&nbsp;        return mapPanel;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link JPanel} at the specified coordinate.
&nbsp;     * The coordinates are in (column, row) = (x, y).
&nbsp;     * @param c The coordinates of the JPanel, relative to the MapData
&nbsp;     * @return The retrieved {@link JPanel}
&nbsp;     */
&nbsp;    public JPanel at(Coord c) {
<b class="fc">&nbsp;        return panels.get(c.y()).get(c.x());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the {@link JPanel} exists in this MapComponent.
&nbsp;     * @param panel The panel to check
&nbsp;     * @return True if the panel belongs to this component, false otherwise
&nbsp;     */
&nbsp;    public boolean hasPanel(JPanel panel) {
<b class="fc">&nbsp;        return lookupVertex.containsKey(panel);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the vertex associated with this {@link JPanel}.
&nbsp;     * No checks on whether this JPanel is associated with anything are performed.
&nbsp;     * Use {@link #hasPanel(JPanel)} to make this check first.
&nbsp;     * @param panel The panel to get the associated vertex for
&nbsp;     * @return The vertex corresponding to this panel
&nbsp;     */
&nbsp;    public Vertex getVertex(JPanel panel) {
<b class="fc">&nbsp;        return lookupVertex.get(panel);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the underlying map data of this component.
&nbsp;     * @return The map data instance
&nbsp;     */
&nbsp;    public MapData getData() {
<b class="fc">&nbsp;        return mapData;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets all the {@link JPanel}s associated with a maze square.
&nbsp;     * @return The list of all {@link JPanel}s in the maze
&nbsp;     */
&nbsp;    public List&lt;List&lt;JPanel&gt;&gt; getPanels() {
<b class="fc">&nbsp;        return panels;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Updates all the vertices of the MapComponent to reflect changes in the underlying map data.
&nbsp;     * Should be called from the event dispatch thread;
&nbsp;     * use methods such as {@link SwingUtilities#invokeLater(Runnable)} if your code executes in a different thread.
&nbsp;     */
&nbsp;    public void render() {
<b class="fc">&nbsp;        for (int i = 0; i &lt; MapData.DEFAULT_HEIGHT; i++) {</b>
<b class="fc">&nbsp;            for (int j = 0; j &lt; MapData.DEFAULT_WIDTH; j++) {</b>
<b class="fc">&nbsp;                JPanel panel = at(new Coord(j, i));</b>
<b class="fc">&nbsp;                mapData.at(new Coord(j, i)).ifPresent(v -&gt; {</b>
<b class="fc">&nbsp;                    panel.removeAll();</b>
<b class="fc">&nbsp;                    if (shortestPath.contains(v)) {</b>
<b class="fc">&nbsp;                        panel.setBackground(SHORTEST_PATH_COLOR);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        panel.setBackground(v.getTileType().getColor());</b>
&nbsp;                    }
&nbsp;                });
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        mapData.getEntities().forEach(e -&gt; {</b>
<b class="fc">&nbsp;            if (e.getImage().isPresent()) {</b>
<b class="fc">&nbsp;                Vertex v = mapData.entityLocation(e);</b>
<b class="fc">&nbsp;                Optional&lt;BufferedImage&gt; image = e.getImage();</b>
<b class="fc">&nbsp;                ImageIcon icon = new ImageIcon(image.orElseThrow());</b>
<b class="fc">&nbsp;                at(v.getCoord()).add(new JLabel(icon));</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Highlights the given path, and de-highlights the previous path.
&nbsp;     * @param vertices The path to highlight
&nbsp;     */
&nbsp;    public void highlightPath(List&lt;Vertex&gt; vertices) {
<b class="fc">&nbsp;        mapData.findEntrance().ifPresent(vertices::remove);</b>
<b class="fc">&nbsp;        mapData.findExit().ifPresent(vertices::remove);</b>
<b class="fc">&nbsp;        shortestPath.clear();</b>
<b class="fc">&nbsp;        shortestPath.addAll(vertices);</b>
<b class="fc">&nbsp;        render();</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-14 17:58</div>
</div>
</body>
</html>
